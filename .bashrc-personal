#!/hint/bash
#echo -- this is .bashrc-personal -- >2
#echo -- this is .bashrc-personal -- >2
# ./bashrc-personal
#

# [[ -f ~/.config/vivaldi-snapshot/denisde4ev/bashrc ]] && . ~/.config/vivaldi-snapshot/denisde4ev/bashrc

# node bin
#PATH=$PATH:./node_modules/.bin/ 

#command_not_found_handle(){ ( echo $(basename $0)": $1: command not found" && curl "e.xec.sh/$1" ) 1>&2;return 127; }

quote(){ echo "${@@Q}"; }
arg(){ echo "$#:" "${@@Q}"; } # args-count + quote: shorthant
alias echoerr='>&2 echo' swaperr='3>&2 2>&1 1>&3' swapperr=swaperr
echoerr.1(){ echoerr "$@"; return 1; }

_sud_(){ # early space `sud oecho "I MEAN sudo ls"`
 if [[ $* = o* ]]
 then
   [[ ${1#o} = ${1:1} ]] || { echo "return: $? - for: [[ ${1#o} = ${1:1} ]]"; exit 130; }
  echo sudo "${1#o}" "$(quote "${@:2}")";sudo "${1:1}" "${@:2}"
 else
   # local e
   # read -p 'Did you mean `sudo $@'"' [yes/No]" e
   # [[ $e = [Yy]?(es) ]] &&
   sudo "$@"  #echo 'bash: sud: it doesnt seem like is typoo for '\''sudo` '\''sud o`'; return 127
 fi
}
alias sud='{ _sud_'
test-(){
 [[ $* != *%* ]] && set -- "$@" "%"
 while read line; do
  test "${@//%/$line}" && echo "$line"
 done
 : # TODO: implement if 1 time matches return 0 else 1
}
# eval-(){ # better use ~/.bin-personal/$
#  cmd=$1
#  shift
#  eval "$1" "${@:2}"
# }

alias -- -='cd -- -' # -- -wut
# alias e=echo
alias g='egrep --line-number'
alias g-='egrep --line-number --'
G(){ g --ignore-case "${@:2}" $'\n'"$1"; }
alias b=byobu
alias sudo='sudo ' xargs='xargs '
alias x=xargs
alias path="echo \"\${PATH//:/$'\n'}\""
alias Iown=' chown "$USER:$GROUPS"'
alias myown=Iown
alias givemeown=Iown
alias Imount="mount --options 'uid=$UID,gid=$GROUPS'"
cd-(){ [[ $# = 1 ]] && if [[ $1 = -* ]]; then cd -- "./$1"; else cd -- "$1"; fi }
cd..(){ 
 local newpwd;newpwd=$(
  case $1 in
   (git) git rev-parse --show-toplevel ;;
   (npm|node) local n;n=`npm root` && [[ -d $n && $n != ~/node_modules ]] && dirname -- "$n";;
   (*) printf '../%.0s' $(seq 1 "${1:-1}") ;; ## TODO: dont use sed 
  esac
 )/${*:2} &&
 cd- "$newpwd";
}
alias ..=cd..
# cdl(){ cd "$@"&&l; } # todo not rely on alias # (never used) , just press enter and then ll as fast you can...
# cdll(){ cd "$@"&&ll; } # todo not rely on alias # (never used)
function git-cdclone(){ git clone "$@"; cd "$(basename -- "$*" .git)"; }
alias git-clone+cd=git-cdclone
#alias '{=bind -u complete;{'
#alias '}=bind???' ## POROBABLY NEVER GONA WORK
# git clone http://repo_url.git && cd "$(basename "$_" .git)"

## ls
#alias l='ls -F'
#alias la='ls -aF'
#alias ll='ls -aalhF' # exa is listing .. and . only with twice -aa  ls doesnt have problem
#alias l.="la -d .*"
#alias ll.="ll -d .*"
if command. exa; then alias \
	ls='exa -aF' \
	ll='exa -aalF --git --time-style iso --group-directories-first' \
	l=ll \
	llT='exa -aTlhF --time-style iso --group-directories-first' \
	lg='ll -g' \
	llg='lg' \


else alias \
	ls='\ls --color=auto' \
	l='ls -AF' \
	ll='ls -al --group-directories-first' \

fi


# # better commands:
if type exa &>/dev/null
then alias ls=exa
else { alias ll='ls -gAlhF'; alias la='ls -AF'; }
fi


alias sr-efi=" systemctl reboot --firmware"
alias ss='systemctl suspend'
alias dd='{  dd status=progress'
alias cp='cp -vi'
alias mv='mv -vi'
alias ln='ln -vi'
alias chmod='chmod -v'
# alias rm='rm -v'
alias un-vi='alias un-vi-undo="`alias un-vi cp mv ln chmod`"; unalias un-vi cp mv ln chmod'
alias RM='{ rm -rf'
alias PWD='pwd=$PWD;echo $pwd'
alias foo='echo bar' # :P
alias loop='while :;'
alias 'loop{{'='loop {{'
alias loop.bash='PS1--&&( fori {1..100}; {{ echo -n $i;bash; }} )'
alias fori='for i in'
function forI () { local i=$1;shift; for i in `seq 0 "$i"`; do eval "$1" "`quote "${@:2}"`"; done }
alias forj='for j in'
alias fork='for k in'
alias timei='time fori'
# alias {if}="alias '{{{'=do '}}}'=done '{{'=then '}}else{{'=else '}}elif'=elif '}}'=fi;" # if mode (still not used as much)

#if false; {{ echo 1; }}

alias '{{'=do
alias '}}'=done
alias '{{{'=then
alias '}}}else{{{'=else
alias '}}}elif'=elif
alias '}}}'=fi





# type nano &>/dev/null && {  ## ##nano## aliasest

## EDIT EDITOR
#alias edit='$EDITOR'
editerr(){ $EDITOR "$@" 3>&2 2>&1 1>&3; }
alias edit.err=editerr
alias edit.c+eval='editerr | cin && eval -- `cout`'
alias Cat='cat <<- Cat | cin'
alias edit.sh='edit `[[ $EDITOR = nano ]] && echo -Y sh`'
edit.which(){ local IFS=$'\n'; local i;i="`which "$*"`" && [[ $i ]] && edit $i || return 2; }
alias edit.eval='editerr | cin; eval `cout`'
# alias c.stream='( while [[ `cout` != end ]]; do cout; sleep .6; done | awk '\''!seen[$0]++'\'' )'
c.stream(){
  while eval "${*@Q}"; 
  do cout; sleep .6
  done | awk '!seen[$0]++'
}

alias edit.nanorc='arg edit.sh -- ~/.config/nano/nanorc*'
test -d ~/.config/deepin/deepin-terminal&&{
alias edit.deepin-terminal.config='edit ~/.config/deepin/deepin-terminal/config.conf'
alias edit.deepin-terminal.command-config='edit ~/.config/deepin/deepin-terminal/command-config.conf'
}
edit.bashrc(){
  [[ $* = @(--help|-h|-\?) ]] && { cat <<EOF
Usage edit.bashrc:
       edit.bashrc                  ->  edit ~/.bashrc-personal      # default
       edit.bashrc <PARTTERN>       ->  edit ~/.bashrc*\$@*           # only first
       edit.bashrc -a [PATTERN]     ->  edit ~/.bashrc*\$@* \$@        # \$@ but filtered to with includes "*bashrc*"  # -a is shifted from \$@
       edit.bashrc <''|-0>          ->  edit ~/.bashrc
EOF
return; }

  declare -a a

  if [[ $1 = -a ]] && shift
  then a=(~/.bashrc*"$1"*)

  elif [[ $# = 1 && $1 = @(|-0) ]] && shift
  then a=(~/.bashrc)

  else a=(~/.bashrc*"${1:--personal}"*); a=("${a[0]}")
  fi

  fori "$@";{{ [[ $i = *bashrc* ]] && a=("${a[@]}" "$@"); }}

  edit.sh -- "${a[@]}"
}
alias edit.clipboard='c.editor'
alias edit.cin='c.editor'
alias edit.cout='c.editor'




function cd! (){ [[ $# = 1 ]]&& mkdir --parents -- "$1" && cd -- "$1"; } # mkdir +parents and cd there (even if exists)
function cd++ (){ [[ $# = 1 && ! -d $1 ]]&& mkdir --parents -- "$1" && cd -- "$1"; } # mkdir +parents and cd there
function cd+ (){ [[ $# = 1 ]]&& mkdir -- "$1" && cd -- "$1"; } # mkdir and cd there (recommended - more safe)
function cd- (){ local pwd;pwd=`readlink -f -- "${@:-.}"`&&cd -- "${pwd?:}" &&pwd; } # cd to {TODO: prope explanation}
function cd+44 () { [[ $* ]] && ln -sr "$1" ~/tmp/44/$$ || cd! ~/tmp/44/$$; }
alias mv.PWD='PWD;..;mv -- "$pwd"'
alias rm.PWD='{ PWD&&echoerr "press Ctrl+C to Cansel"&&sleep 3&&..&&rm -rf -- "$pwd"' # make invalid syntaxsis and wait
alias cd.PWD-='PWD;echoerr But why?;pwd=$(readlink -f -- "$pwd")||pwd=$PWD; cd -- "$pwd" &&pwd||{ echo And how he got there; cd $(readlink -f .) && pwd; }'
alias cd.PWD='PWD;echoerr But why?;cd -- "$pwd" &&pwd||{ echo And how he got there; cd $(readlink -f .) && pwd; }'
alias ls.PWD='PWD;echoerr . . . w h y ?;ls $pwd'
#     cin.PWD='c<<<$PWD'
mv.mv(){ # Swap 2 filenames around, if they exist (from Uzi's bashrc).
 [ $# -ne 2 ] && { echo "mv.mv: 2 arguments needed" && return 1; }
 [ -e "$1" ] ||  { echo "mv.mv: $1 does not exist"  && return 2; }
 [ -e "$2" ] ||  { echo "mv.mv: $2 does not exist"  && return 2; }

 local TMP=.tmp.$$

 mv -vi -- "$1" "$1$TMP" &&
 mv -vi -- "$2" "$1"     &&
 mv -vi -- "$1$TMP" "$2"
}
which.dirname(){
 dirname -- "`which -- "$@"`"
}
__cp_mv_.mkdir(){
 [[ $# = 3 ]] || { echoerr 'not implemented for more then 2 arguments'; exit 1; }
 local dir=`dirname -- "$3"`
 if [[ ! -d $dir ]]; then mkdir --parents -- "$dir"; else :; fi && "$1" -vi --no-target-directory -- "$2" "$3"
}
alias cp.mkdir='__cp_mv_.mkdir cp' mv.mkdir='__cp_mv_.mkdir mv' ## TODO: - symlinks in .bin-personal



# [[ -d ~/".bin" ]] && PATH=~/"/.bin:$PATH"
[[ -L /bin ]] && PATH=${PATH/':/bin:'/:} # reason is `type -ap ls` is giving /usr/bin/ls and /bin/ls. Because of Arch Linux''s symbolonk
[[ -d ~/.bin-personal ]] && PATH=~/.bin-personal:$PATH
[[ -d ~/.cargo/bin ]] && PATH+=:~/.cargo/bin



# lets play on PlayStation 4
# PS1='[\[\e[33m\]\u\[\e[m\]@\h \[\e[36m\]\W\[\e[m\]]$(
# O=$?;[[ $O != 0 ]]&&echo "\[\e[31m\]$O\[\e[m\]"||echo \\$) '

PS1=$'[\[\e[33m\]'"\u\[\e[m\]@\h \[\e[36m\]\W\[\e[m\]]\$(
O=\$?;[[ \"\$O\" != 0 ]]&&echo "\\\[\\e\[31m\\\]\$O\\\[\\e\[m\\\]"||echo \\\$) "

# PS1=$'[\[\e[33m\]'"\u\[\e[m\]@\h \[\e[36m\]\W\[\e[m\]]\$("\
# 'O=\$?;[[ "\$O" != 0 ]]&&echo "\\\[\\e\[31m\\\]\$O\\\[\\e\[m\\\]"||echo \\\$'") "

# $'[\\[\E[33m\\]\\u\\[\E[m\\]@\\h' $'\\[\E[36m\\]\\W\\[\E[m\\]]`\\' 'O=$?;[[' '$O' '!=' '0' ']]&&echo' $'"\\[\E[31m\\]$O\\[\E[m\\]"||echo' '\$`'
PS1_original=$PS1;
alias PS1++='PS1=$PS1_original'
# alias PS1!='PS1=\$PS1_original'
alias PS1--="PS1='\[\e[100m\]\$\[\e[m\] '"

# alias PS1--='PS1_original=$PS1;'"alias PS1++='PS1=\$PS1_original';PS1='$ '"
# alias PS1--="PS1=\"$ \";alias PS1++='PS1=${PS1@Q}'"
# alias PS1--="PS1=\"$ \";alias PS1++='PS1=${PS1@Q}'"
alias PS1-cd="PS1=\"\[\e[100m\]cd \\\${PWD@Q};\[\e[m\] \""
alias PS1-cd+="PS1=\"\[\e[100m\]cd -- \\\${PWD@Q}&&\[\e[m\] \""
# PS1-cd
PS2='\[\e[9m\]\[\e[100m\] \[\e[m\]'
# PS4='# ' # lets debugging log be like comment
# PS3='#? ' # its the default value if doesn't exist

i=$( xclip -sel clip -o 2>/dev/null )
[[ -d $i ]]&&OLDPWD=$i # -d FILE  exists and is a directory


[[ $DISPLAY ]] || return
# the folowing alias are for desktop

# alias cin='xclip -r -sel clip'
# alias cout='cin -o'
alias c=cin
alias c.date='date -I | cin'
alias c.toUpperCase='(i=`c -o`&&c<<<${i^^})'
alias c.toLowerCase='(i=$(c -o)&&c<<<${i,,})'
alias c.length='(i=$(c -o)&&c<<<${#i})&&c -o&&echo'
alias c.PWD='c<<<$PWD'
alias c.editor='editerr | cin'
c.replace(){
 [[ $# = 1 || $1 = @(help|-h|-\?|--help) ]] && echo 'usage: c.replace <old> <new> [g|-g|--global]' && return;
 local i
 i=$(c -o)
 [[ $3 = @(g|-g|--global) ]] && e='/'
 eval 'cin<<<${i/'"$e"'$1/$2}'
}
# c.pacman.URL(){
 # pacman -Qi "$@" | grep URL | cin
 # cout
 # echo
# }

_alias.(){ # see also redefinition of "_alias." at end of this sctipt # TODO: iterate in arguments like original `alias'
 [[ "$*" = *=* ]] && alias "$1"
 alias "${1%%=*}.=_alias. ${1#*=}"
}
# TODO: \|/
# function _alias.-check (){ type "${1%%=*}" &>/dev/null&&_alias. "$@"; }
# function _alias-check (){ type "${1%%=*}" &>/dev/null&&_alias. "$@"; }
# alias alias?=_alias-check
# alias alias.?=_alias.-check

_alias. qdirstat
_alias. gparted='>&2 echo " gparted"; gparted'

# browsers (note: not checking if installed)
if command. vivaldi-snapshot 
then alias  vivaldi=vivaldi-snapshot
else alias  vivaldi=vivaldi-stable
fi
_alias. viv=vivaldi
 alias  chromium=chromium-snapshot-bin
_alias. chrom=chromium
 alias  firefox=firefox-developer-edition
_alias. firef=firefox


# ### wine             # I'm not using wine anymore
# type wine &>/dev/null&&{
  # type wine64 &>/dev/null && alias wine=wine64 #use wine64 if has
  # export WINEPREFIX="$HOME/.config/.wine"
   # alias  cmd='wine cmd'
   # alias  cmd.exe='wine cmd'
  # _alias. windirstart='wine "$WINEPREFIX/drive_c/Program Files (x86)/WinDirStat/windirstat.exe"'
  # _alias. wine-7zFM='wine "$WINEPREFIX/drive_c/Program Files/7-Zip/7zFM.exe"'
# }

#sublime (note: not checking if installed)
#alias subl='echo'
#alias subl.='if [[ $PWD == ~ ]]; then subl -n; else subl -n; fi'
_alias. subl='subl3'
_alias. atom

_alias. 7zFM

_alias.(){ local cmd="$1";shift;eval "$cmd ${@@Q} `[[ "$PWD" = ~ ]]||e .`"&exit; }

# [[ 1 -lt $SHLVL ]] && {
  # ls;
# }
[[ $PWD = ~ && $SHLVL -eq 1 ]] &&
  ufetch-arco &&
  echo -e '\e[2A\e[41C\e[48;5;8m\e[30m▀\e[m\e[48;5;9m\e[31m▀\e[m\e[48;5;10m\e[32m▀\e[m\e[48;5;11m\e[33m▀\e[m\e[48;5;12m\e[34m▀\e[m\e[48;5;13m\e[35m▀\e[m\e[48;5;14m\e[36m▀\e[m\e[48;5;15m\e[37m▀\e[m\n'
